import os
import subprocess
import threading
from pathlib import Path
from flask import Flask, render_template, request, jsonify, send_file

BASE_DIR = Path(__file__).resolve().parent.parent  # project root
BUILD_DIR = BASE_DIR / "build"
CONFIG_PATH = BASE_DIR / "config.ini"
INPUT_DIR = BASE_DIR / "input" if (BASE_DIR / "input").exists() else BASE_DIR
OUTPUT_DIR = BASE_DIR / "output" if (BASE_DIR / "output").exists() else BASE_DIR

app = Flask(__name__)

KEYS = [
    "input_file", "output_file", "dict_dir", "mode",
    "topk", "time_range", "work_type", "normalize"
]


def read_config():
    cfg = {}
    if CONFIG_PATH.exists():
        for line in CONFIG_PATH.read_text(encoding="utf-8").splitlines():
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if '=' not in line:
                continue
            k, v = line.split('=', 1)
            k, v = k.strip(), v.strip()
            if k in KEYS:
                cfg[k] = v
    return cfg


def write_config(updates: dict):
    cfg = read_config()
    # dict_dir and mode are backend-controlled; ignore changes from UI
    filtered = {k: str(v) for k, v in updates.items() if k in KEYS and k not in ("dict_dir", "mode")}
    cfg.update(filtered)
    lines = ["# Auto-generated by webui",]
    for k in KEYS:
        if k in cfg:
            lines.append(f"{k} = {cfg[k]}")
    CONFIG_PATH.write_text("\n".join(lines) + "\n", encoding="utf-8")


def find_hotwords_exe() -> Path | None:
    # try build/bin/hotwords.exe then build/hotwords.exe
    cand = [BUILD_DIR / "bin" / "hotwords.exe", BUILD_DIR / "hotwords.exe"]
    for p in cand:
        if p.exists():
            return p
    return None


@app.get("/")
def index():
    cfg = read_config()
    return render_template("index.html", cfg=cfg)


@app.get("/api/config")
def api_get_config():
    return jsonify(read_config())


@app.post("/api/config")
def api_set_config():
    data = request.json or {}
    write_config(data)
    return jsonify({"ok": True, "config": read_config()})


@app.post("/api/run")
def api_run():
    exe = find_hotwords_exe()
    if not exe:
        return jsonify({"ok": False, "error": "hotwords.exe not found. Build the project first."}), 400

    # Run from build dir so relative paths behave like your current flow
    try:
        res = subprocess.run([str(exe)], cwd=str(BUILD_DIR), capture_output=True, text=True, timeout=300)
        ok = res.returncode == 0
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500

    cfg = read_config()
    output_file = cfg.get("output_file", "output.txt")
    out_path = (OUTPUT_DIR / output_file) if (OUTPUT_DIR / output_file).exists() else (BASE_DIR / output_file)

    preview = ""
    if out_path.exists():
        try:
            preview = out_path.read_text(encoding="utf-8", errors="replace")
        except Exception:
            preview = "(unable to read output file)"

    return jsonify({
        "ok": ok,
        "stdout": res.stdout,
        "stderr": res.stderr,
        "output_path": str(out_path),
        "output_preview": preview[-4000:],  # last 4k chars
    })


@app.post("/api/upload_input")
def api_upload_input():
    f = request.files.get('file')
    if not f:
        return jsonify({"ok": False, "error": "No file uploaded"}), 400
    INPUT_DIR.mkdir(parents=True, exist_ok=True)
    # Windows-safe file name
    filename = Path(f.filename).name
    save_path = INPUT_DIR / filename
    f.save(str(save_path))
    # Update config to use this file name (relative name)
    write_config({"input_file": filename})
    return jsonify({"ok": True, "saved_path": str(save_path), "config": read_config()})


def parse_output_snapshots(text: str):
    # Parse blocks like:
    # Query Time: 15 minute
    # 1: 人工智能/nr/3
    # 2: 技术/n/2
    snapshots = []
    lines = text.splitlines()
    i = 0
    while i < len(lines):
        line = lines[i]
        if line.startswith("Query Time:"):
            # Extract minute number
            time = line.replace("Query Time:", "").replace("minute", "").strip()
            items = []
            j = i + 1
            while j < len(lines):
                l = lines[j].strip()
                if not l or l.startswith("[") or l.startswith("Query Time:"):
                    break
                # Expected format: k: word/tag/count
                try:
                    # split on ':', then word/tag/count by '/'
                    parts = l.split(":", 1)
                    rest = parts[1].strip()
                    wtc = rest.split("/")
                    word = wtc[0]
                    count = int(wtc[-1])
                    items.append({"word": word, "count": count})
                except Exception:
                    pass
                j += 1
            snapshots.append({"time": time, "items": items})
            i = j
        else:
            i += 1
    return snapshots


@app.get("/api/output_parsed")
def api_output_parsed():
    cfg = read_config()
    output_file = cfg.get("output_file", "output.txt")
    out_path = (OUTPUT_DIR / output_file) if (OUTPUT_DIR / output_file).exists() else (BASE_DIR / output_file)
    if not out_path.exists():
        return jsonify({"ok": False, "error": "Output file not found"}), 404
    text = out_path.read_text(encoding="utf-8", errors="replace")
    snaps = parse_output_snapshots(text)
    return jsonify({"ok": True, "snapshots": snaps})

# ===================== Interactive console (work_type=2) =====================
console_proc = None
console_buf = []
console_lock = threading.Lock()

def _console_reader(proc: subprocess.Popen):
    try:
        for line in proc.stdout:
            with console_lock:
                console_buf.append(line.rstrip("\r\n"))
    except Exception:
        pass

@app.post("/api/console/start")
def api_console_start():
    global console_proc
    if console_proc and console_proc.poll() is None:
        return jsonify({"ok": True, "msg": "console already running"})
    exe = find_hotwords_exe()
    if not exe:
        return jsonify({"ok": False, "error": "hotwords.exe not found"}), 400
    cfg = read_config()
    # Ensure work_type=2
    if cfg.get("work_type") != "2":
        write_config({"work_type": "2"})
    try:
        proc = subprocess.Popen(
            [str(exe)], cwd=str(BUILD_DIR),
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, bufsize=1, encoding="utf-8"
        )
        console_proc = proc
        with console_lock:
            console_buf.clear()
        t = threading.Thread(target=_console_reader, args=(proc,), daemon=True)
        t.start()
        return jsonify({"ok": True})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500

@app.post("/api/console/input")
def api_console_input():
    global console_proc
    if not console_proc or console_proc.poll() is not None:
        return jsonify({"ok": False, "error": "console not running"}), 400
    data = request.json or {}
    # Support single line, multi-line text, or list of lines
    lines_payload = []
    if "lines" in data and isinstance(data["lines"], list):
        lines_payload = [str(x) for x in data["lines"]]
    elif "text" in data and isinstance(data["text"], str):
        # splitlines keeps logical lines; filter out trailing CRs
        lines_payload = [s.rstrip("\r") for s in data["text"].splitlines()]
    else:
        line = data.get("line", "")
        if line is not None:
            lines_payload = [str(line)]
    try:
        for ln in lines_payload:
            if ln == "":
                # send a bare newline to allow blank lines if user wants
                console_proc.stdin.write("\n")
            else:
                console_proc.stdin.write(ln + "\n")
        console_proc.stdin.flush()
        return jsonify({"ok": True})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500

@app.get("/api/console/output")
def api_console_output():
    with console_lock:
        tail = console_buf[-500:]
    return jsonify({"ok": True, "lines": tail})

@app.post("/api/console/stop")
def api_console_stop():
    global console_proc
    if console_proc and console_proc.poll() is None:
        try:
            console_proc.terminate()
        except Exception:
            pass
    console_proc = None
    with console_lock:
        console_buf.clear()
    return jsonify({"ok": True})


@app.get("/download/output")
def download_output():
    cfg = read_config()
    output_file = cfg.get("output_file", "output.txt")
    out_path = (OUTPUT_DIR / output_file) if (OUTPUT_DIR / output_file).exists() else (BASE_DIR / output_file)
    if not out_path.exists():
        return jsonify({"ok": False, "error": "Output file not found."}), 404
    return send_file(str(out_path), as_attachment=True, download_name=output_file)


if __name__ == "__main__":
    # FLASK run
    port = int(os.environ.get("PORT", 8080))
    app.run(host="127.0.0.1", port=port, debug=True)
